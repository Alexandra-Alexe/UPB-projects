Tema 1 APD

Pornind de la implementarea secvențială, am paralelizat, cu ajutorul Pthreads un program care generează contururi pentru hărți topologice folosind algoritmul Marching Squares. Scopul final a fost de a se obține aceleași fișiere de ieșire ca la varianta secvențială, dar cu timpi de execuție îmbunătățiți. 

Pentru început  a fost necesar să includ fișierul "pthread_barrier_mac.h" (luat
din cadrul laboratorului) deoarece am lucrat local pe Mac M1, altfel nu aș fi putut utiliza bariere. Pentru că nu ni s-a permis folosirea variabilelor globale, mi-am creat tipul de structura Structure conținând câmpurile necesare în functia executată de toate threadurile. Am creat aceste campuri de tip pointer, in cazul in care nu erau, sau am mai adaugat un * pentru a realiza prelucrarile tuturor threadurilor pe aceleasi variabile. 

- In funcția main se citește imaginea, se declara variabilele necesare și se inițializează bariera. Se inițializează tabela de căutare a contururilor și se verifică dacă e necesară scalarea imaginii. Acest pas este foarte important în cazul pozelor de dimensiuni mari, prin urmare paralelizarea interpolarii bicubice influențează major eficiența ca timp a programului. Funcția rescale_image, primește ca parametrii imaginea citită si variabila rescale în care marchează daca e necesară sau nu scalarea. Apoi se parcurg threadurile, se construiește structura fiecaruia și sa apeleaza pthread_create cu funcția rescale_grid_march_update și cu structura threadului corespunzător. Ulterior se dă join threadurilor pentru a reveni doar la threadul principal, se face scrierea imaginii, distrugerea barierei si se apelueaza funcția de eliberare a resurselor.
 - Nu a fost necesar să modific varianta secvențială a funcției init_contour_map. 
 - În funcția free_resources, am eliminat instrucțunile prin care se elibera memoria pentru grid, întrucât am modificat alocarea sa cu una statica, cunoscându-i dimensiunile. 
 - În functia rescale_image am păstrat alocările de memorie, însă interpolarea bicubila am mutat-o în funcția executată de toate threadurile create cu pthread_create. Interpolarea se realizeaza prin verificarea variabilei rescale, a cărei valoare se stabileste în rescale_image în funcție de necesitatea de a rescala imaginea sau nu.
  - În funcția rescale_grid_march_update, comuna tuturor threadurilor, am încorporat funcțiile update_image, sample_grid, march și interpolarea bicubica. Cu ajutorul structurii date ca parametru, am accesat câmpurile necesare: câmpul thread_id este unic pentru fiecare thread, în timp ce toate celelalte câmpurile coincid. De exemplu, toate threadurile lucreaza pe aceeași scaled_image. Se verifică variabila rescale, pentru a rula algoritmul paralelizat de interpolare bicubica. Am folosit variabilele start_res_x, end_res_y pentru a stabili intervalele de lucru pentru fiecare thread. Ulterior, cu ajutorul unei bariera mă asigur ca este finalizata imaginea scalata înainte de a o utiliza. Urmează calculul gridului, pe care l-am alocat static cunoscându-i dimensiunile p+1, respectiv q+1, unde p si q reprezinta numarul de patrate de dimensiune fixa ale imaginii p pe axa orizontala si pe cea verticala. Pun iar o bariera pentru a mă asigura ca a fost calculat gridul înainte de a fi accesat. Apoi umrează partea de march și update în urma cărora se face înlocuirea pătratelor de dimensiune fixă cu acele contururi predefinite. 
 
